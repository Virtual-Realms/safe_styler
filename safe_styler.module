<?php

/**
 * Implements hook_init().
 */
function safe_styler_init() {

  $file_uri = path_to_theme() . "/css/safe-styles.css";
  if (file_exists($file_uri)) {
    drupal_add_css($file_uri, array(
      'type' => 'file',
      'group' => CSS_THEME,
      'every_page' => TRUE,
      'weight'=> 2000,
      'media' => 'all',
      'preprocess' => TRUE)
    );
  }
}

/**
 * Implements hook_form_system_theme_settings_alter()
 */
function safe_styler_form_system_theme_settings_alter(&$form, &$form_state) {

  // If safe-styles.css exists for the current theme create a form interface
  // for it, otherwise do nothing
  $file_uri = path_to_theme() . "/css/safe-styles.css";
  if (file_exists($file_uri)) {
    $css = file_get_contents($file_uri);
    //drupal_set_message($css);      
    //drupal_set_message(dpm($css));      

    // Add spectrum color picker js and css http://bgrins.github.io/spectrum
    // Requires libraries API and spectrum installed in
    // libraries/bgrins-spectrum as per color_field install instructions
    drupal_add_js(libraries_get_path('bgrins-spectrum') . '/spectrum.js');
    drupal_add_css(libraries_get_path('bgrins-spectrum') . '/spectrum.css');
    $spectrum_js = 'jQuery(".spectrum").spectrum({
      showInput: true,
      allowEmpty: true,
      showAlpha: true,
      showInitial: true,
      showInput: true,
      preferredFormat: "rgb",
      clickoutFiresChange: true,
      showButtons: false
    });';
    drupal_add_js($spectrum_js, array(
      'type' => 'inline',
      'scope' => 'footer',
      'weight' => 5)
    );


    $layout_header  = '<div class=""><div class="layout-header theme-settings-header clearfix">';
    $layout_header .= '<h1>' . t('Safe Styler Settings') . '</h1>';
    //$layout_header .= '<p class="docs-link"><a href="http://adaptivethemes.com/documentation/adaptivetheme-7x-3x" title="View online documentation" target="_blank">View online documentation</a></p>';
    //$layout_header .= '<p class="logo-link"><a href="http://adaptivethemes.com" title="Adaptivethemes.com - Rocking the hardest since 2006" target="_blank"><img class="at-logo" src="' . $logo . '" /></a></p>';
    $layout_header .= '</div>';

    $form['safe_styler'] = array(
      '#type' => 'vertical_tabs',
      '#description' => t('Layout'),
      '#prefix' => $layout_header,
      '#suffix' => '</div>',
      '#weight' => -10,
      //'#attached' => array(
      //  'css' => array(drupal_get_path('theme', 'adaptivetheme') . '/css/at.settings.form.css'),
      //),
    );

    // Parse CSS file into array
    $rules = _safe_styler_css2array($css);

    // Convert CSS rules array to form elements
    foreach($rules AS $i=>$rule) {

      // Begin unique array key
      $unique_key_prefix = 'safe-styler_' . $i . '_';

      // Get and use group from CSS rule comment as title of vertical tab
      $group = $rule['group'];
      if (!array_key_exists($group, $form['safe_styler'])) { // don't overwrite existing
        $form['safe_styler'][$group] = array(
          '#type' => 'fieldset',
          '#title' => $group,
        );
      }

      // Also store CSS group in hidden form field
      $unique_key = $unique_key_prefix . 'group';
      $form['safe_styler'][$group][$unique_key] = array(
        '#type' => 'hidden',
        '#value' => $group,
      );

      // Get and use CSS rule comment as title of inner fieldset
      $comment = $rule['comment'];
      if (!array_key_exists($comment, $form['safe_styler'][$group])) { // don't overwrite existing
        $form['safe_styler'][$group][$comment] = array(
          '#type' => 'fieldset',
          '#title' => $comment,
        );
      }

      // Also store CSS comment in hidden form field
      $unique_key = $unique_key_prefix . 'comment';
      $form['safe_styler'][$group][$comment][$unique_key] = array(
        '#type' => 'hidden',
        '#value' => $comment,
      );

      // Get and store CSS selector in hidden form field
      $unique_key = $unique_key_prefix . 'selector';
      $selector = $rule['selector'];
      $form['safe_styler'][$group][$comment][$unique_key] = array(
        '#type' => 'hidden',
        '#value' => $selector,
      );

      // Process CSS declarations and flag which property is last so that we can
      // close the declaration block when generating and saving the CSS on submit
      $declarations = $rule['declarations'];
      $num_declatations = count($declarations);
      $index = 0;
      foreach($declarations AS $property=>$value) {
        $index++;
        $last_flag = ($index == $num_declatations) ? '-last_' : '_';
        $unique_key = $unique_key_prefix . 'property' . $last_flag . $property;
        $form['safe_styler'][$group][$comment][$unique_key] = _safe_styler_get_form_elements($property, $value);
      }
    }
    
    // Attach custom submit handler to the form
    $form['#submit'][] = '_safe_styler_system_theme_settings_submit';

    //dpm($form);
  }
}


/**
 *  Return the correct form element array for a CSS property:value pair.
 */
function _safe_styler_get_form_elements($property, $value) {

  $elements = array();

  // Convert CSS property to form field label
  $title = ucwords(str_replace("-", " ", $property));

  switch ($property) {
    case "color":
    case "border-color":
    case "background-color":
      $elements = array(
        '#type' => 'textfield',
        '#title' => $title,
        '#default_value' => $value,
        '#attributes' => array('class' => array('spectrum')),
      );
      break;
    case "font-family":
      $elements = array(
        '#type' => 'textfield',
        '#title' => $title,
        '#default_value' => $value,
        //'#attributes' => array('class' => array('spectrum')),
      );
      break;
  }

  return $elements;
}

$multipart_values = array('width');

/**
 *  Determine whether a CSS property requires multiple form elements to
 *  manipulate its value e.g. 'width' is comprised of 'auto or other' (select
 *  list), numeric value (text entry) and units e.g. 'px' (select list).
 */
function _safe_styler_has_multipart_value($property) {
  return in_array($property, $multipart_values);
}

/**
 *  Custom submit handler for theme settings form.
 */
function _safe_styler_system_theme_settings_submit(&$form, &$form_state) {

  // Regenerate CSS file based on form values
  $css = '';

  foreach($form_state['values'] AS $key=>$value) {
    $key_parts = explode('_', $key);
    if($key_parts[0] == 'safe-styler') {
      $index = $key_parts[1];
      $type = $key_parts[2];

      switch ($type) {
        case 'group':
          $css .= "/* " . $value . ": ";
          break;
        case 'comment':
          $css .= $value . " */\r\n";
          break;
        case 'selector':
          $css .= $value . " {\r\n";
          break;
        case 'property':
        case 'property-last':
          $property = $key_parts[3];
          $css .= "  " . $property . ": " . $value . ";\r\n";
          break;
      }

      if ($type == 'property-last') {
        $css .= "}\r\n\r\n";
      }
    }
  }

  // Save regenerated CSS file to theme
  $file_uri = path_to_theme() . "/css/safe-styles.css";
  file_unmanaged_save_data($css, $file_uri, FILE_EXISTS_REPLACE);
}

/**
 *  Convert CSS (including above-rule comments) into an array.
 */
function _safe_styler_css2array($css)
{
  $results = array();

  // Find CSS comments and rules using regex voodoo
  $regex_comment = '/\*(.*?)\*/';
  $regex_selector = '(.*?)';
  $regex_declarations = '\{(.*?)\}';
  $regex_pattern = '#' . $regex_comment . $regex_selector . $regex_declarations . '#sm';
  preg_match_all($regex_pattern, $css, $matches);

  // Process each match 
  foreach($matches[0] AS $i=>$match)
  {
    // Split CSS comments into group, which becomes a vertical tab title
    // and comment which becomes the fieldset title
    $comments = explode(":", $matches[1][$i]);
    if (count($comments) < 2) {
      $group = "Other";
      $comment = trim($comments[0]);
    } else {
      $group = trim($comments[0]);
      $comment = trim($comments[1]);
    }
    $results[$i]['group'] = $group;
    $results[$i]['comment'] = $comment;

    $results[$i]['selector'] = trim($matches[2][$i]);
    $declarations = explode(';', $matches[3][$i]);
    foreach($declarations AS $declaration)
    {
      if (strlen(trim($declaration)) > 0) // for missing semicolon on last element, which is legal
      {
        list($property, $value) = explode(':', $declaration);
        $results[$i]['declarations'][trim($property)] = trim($value);
      }
    }
  }

  return $results;
}